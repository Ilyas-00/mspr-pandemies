# app_simple.py - Streamlit avec login simple & r√¥les
import streamlit as st
import pandas as pd
import plotly.express as px
import requests
from pathlib import Path
import json

# =========================
# Config Streamlit & API
# =========================
# st.set_page_config(page_title="Dashboard Pand√©mies", page_icon="ü¶†", layout="wide")
# API_BASE_URL = "http://localhost:8000"
# =========================
# Config Streamlit & API
# =========================
import os
st.set_page_config(page_title="Dashboard Pand√©mies", page_icon="ü¶†", layout="wide")

# 1) En conteneur: on passe API_BASE_URL="http://api:8000" via docker-compose
# 2) En local (hors Docker): fallback "http://localhost:8000"
API_BASE_URL = os.getenv("API_BASE_URL", "http://localhost:8000")
# --- Pays & flags: lus depuis l'URL par la gateway (8511=US, 8512=FR, 8513=CH)
params = st.experimental_get_query_params()
COUNTRY = (params.get("country", ["US"])[0]).upper()
ENABLE_TECH_API = COUNTRY == "US"
ENABLE_DATAVIZ  = COUNTRY != "CH"

st.caption(f"üåç Country: {COUNTRY} ‚Ä¢ Dataviz: {'ON' if ENABLE_DATAVIZ else 'OFF'} ‚Ä¢ ML: {'ON' if ENABLE_TECH_API else 'OFF'}")


USERS_PATH = Path("users.json")  # persistance tr√®s simple (d√©mo)

# =========================
# Session (√©tat) par d√©faut
# =========================
if "role" not in st.session_state:
    st.session_state.role = "GUEST"       # GUEST | RESEARCHER | ADMIN
if "username" not in st.session_state:
    st.session_state.username = None

# =========================
# Utilitaires users (tr√®s courts)
# =========================
def load_users() -> dict:
    """
    Charge les utilisateurs depuis users.json
    S'il n'existe pas, on cr√©e 2 comptes de base : Admin/Admin1, Chercheur/Chercheur1
    Structure: {"Admin": {"password":"Admin1","role":"ADMIN"}, "Chercheur": {"password":"Chercheur1","role":"RESEARCHER"}}
    """
    if USERS_PATH.exists():
        try:
            return json.loads(USERS_PATH.read_text(encoding="utf-8"))
        except:
            pass
    users = {
        "Admin": {"password": "Admin1", "role": "ADMIN"},
        "Chercheur": {"password": "Chercheur1", "role": "RESEARCHER"},
    }
    USERS_PATH.write_text(json.dumps(users, indent=2), encoding="utf-8")
    return users

def save_users(users: dict) -> None:
    USERS_PATH.write_text(json.dumps(users, indent=2), encoding="utf-8")

USERS = load_users()

# =========================
# Fonctions API (GET) ‚Äî inchang√©
# =========================
@st.cache_data(ttl=300)
def get_api_data(endpoint: str):
    try:
        r = requests.get(f"{API_BASE_URL}{endpoint}", timeout=10)
        if r.status_code == 200:
            return r.json()
        else:
            st.error(f"‚ùå Erreur API: {endpoint} (code {r.status_code})")
            return None
    except requests.exceptions.ConnectionError:
        st.error("‚ùå API non disponible. Lancez : uvicorn api.api_pandemies:app --reload")
        return None
    except Exception as e:
        st.error(f"‚ùå Erreur: {e}")
        return None

def test_api() -> bool:
    try:
        r = requests.get(f"{API_BASE_URL}/", timeout=5)
        return r.status_code == 200
    except:
        return False

# =========================
# Pages (rang√©es en petites fonctions)
# =========================
def page_vue_par_pays(maladie: str):
    st.header(f"üìà Donn√©es {maladie.replace('_', '-').upper()}")
    pays_data = get_api_data(f"/pays/{maladie}")
    if not (pays_data and "pays" in pays_data):
        st.error("‚ùå Impossible de r√©cup√©rer les pays")
        return
    pays_list = [p["nom_pays"] for p in pays_data["pays"]]
    pays_choisi = st.selectbox("üåç Choisir un pays", pays_list)
    if not pays_choisi:
        return
    evo = get_api_data(f"/evolution/{maladie}/{pays_choisi}?limit=5000")
    if not (evo and "donnees" in evo):
        st.error(f"‚ùå Erreur donn√©es pour {pays_choisi}")
        return
    df = pd.DataFrame(evo["donnees"])
    if df.empty:
        st.warning(f"‚ö†Ô∏è Aucune donn√©e pour {pays_choisi}")
        return
    df["date_stat"] = pd.to_datetime(df["date_stat"])
    df = df.sort_values("date_stat")
    st.subheader(f"üìà Cas totaux - {pays_choisi}")
    fig = px.line(df, x="date_stat", y="cas_totaux", title=f"Cas totaux cumul√©s - {pays_choisi}")
    st.plotly_chart(fig, use_container_width=True)
    st.subheader("üìä Nouveaux cas quotidiens (30 derniers jours)")
    fig2 = px.bar(df.tail(30), x="date_stat", y="nouveaux_cas")
    st.plotly_chart(fig2, use_container_width=True)

def page_comparaison(maladie: str):
    # ‚úÖ garde pays
    if not ENABLE_DATAVIZ:
        st.warning("‚ùå Dataviz d√©sactiv√©e pour ce pays.")
        return

    st.header(f"‚öñÔ∏è Comparaison {maladie.replace('_', '-').upper()}")
    pays_data = get_api_data(f"/pays/{maladie}")
    if not (pays_data and "pays" in pays_data):
        st.error("‚ùå Impossible de r√©cup√©rer les pays")
        return
    pays_list = [p["nom_pays"] for p in pays_data["pays"]]
    col1, col2 = st.columns(2)
    with col1:
        pays1 = st.selectbox("üåç Premier pays", pays_list, key="p1")
    with col2:
        idx2 = 1 if len(pays_list) > 1 else 0
        pays2 = st.selectbox("üåç Deuxi√®me pays", pays_list, index=idx2, key="p2")
    if not (pays1 and pays2 and pays1 != pays2):
        st.info("üëÜ S√©lectionnez deux pays diff√©rents")
        return
    evo1 = get_api_data(f"/evolution/{maladie}/{pays1}?limit=5000")
    evo2 = get_api_data(f"/evolution/{maladie}/{pays2}?limit=5000")
    if not (evo1 and evo2 and "donnees" in evo1 and "donnees" in evo2):
        st.error("‚ùå Erreur r√©cup√©ration donn√©es")
        return
    df1 = pd.DataFrame(evo1["donnees"]); df1["date_stat"] = pd.to_datetime(df1["date_stat"]); df1["pays"] = pays1
    df2 = pd.DataFrame(evo2["donnees"]); df2["date_stat"] = pd.to_datetime(df2["date_stat"]); df2["pays"] = pays2
    dfc = pd.concat([df1, df2])
    if dfc.empty:
        return
    typ = st.selectbox("üìà Type de donn√©es", ["cas_totaux", "nouveaux_cas", "deces_totaux", "nouveaux_deces"])
    figc = px.line(dfc, x="date_stat", y=typ, color="pays")
    st.plotly_chart(figc, use_container_width=True)

# def page_comparaison(maladie: str):
#     st.header(f"‚öñÔ∏è Comparaison {maladie.replace('_', '-').upper()}")
#     pays_data = get_api_data(f"/pays/{maladie}")
#     if not (pays_data and "pays" in pays_data):
#         st.error("‚ùå Impossible de r√©cup√©rer les pays")
#         return
#     pays_list = [p["nom_pays"] for p in pays_data["pays"]]
#     col1, col2 = st.columns(2)
#     with col1:
#         pays1 = st.selectbox("üåç Premier pays", pays_list, key="p1")
#     with col2:
#         idx2 = 1 if len(pays_list) > 1 else 0
#         pays2 = st.selectbox("üåç Deuxi√®me pays", pays_list, index=idx2, key="p2")
#     if not (pays1 and pays2 and pays1 != pays2):
#         st.info("üëÜ S√©lectionnez deux pays diff√©rents")
#         return
#     evo1 = get_api_data(f"/evolution/{maladie}/{pays1}?limit=5000")
#     evo2 = get_api_data(f"/evolution/{maladie}/{pays2}?limit=5000")
#     if not (evo1 and evo2 and "donnees" in evo1 and "donnees" in evo2):
#         st.error("‚ùå Erreur r√©cup√©ration donn√©es")
#         return
#     df1 = pd.DataFrame(evo1["donnees"]); df1["date_stat"] = pd.to_datetime(df1["date_stat"]); df1["pays"] = pays1
#     df2 = pd.DataFrame(evo2["donnees"]); df2["date_stat"] = pd.to_datetime(df2["date_stat"]); df2["pays"] = pays2
#     dfc = pd.concat([df1, df2])
#     if dfc.empty:
#         return
#     typ = st.selectbox("üìà Type de donn√©es", ["cas_totaux", "nouveaux_cas", "deces_totaux", "nouveaux_deces"])
#     figc = px.line(dfc, x="date_stat", y=typ, color="pays")
#     st.plotly_chart(figc, use_container_width=True)

def page_taux_transmission():
    # ‚úÖ garde pays
    if not ENABLE_TECH_API:
        st.warning("‚ùå API technique (ML) indisponible pour ce pays.")
        return

    st.header("üìâ Taux de transmission (observ√© vs pr√©dit)")
    # 1) pays disponibles c√¥t√© API ML
    try:
        resp = requests.get(f"{API_BASE_URL}/ml/available_countries", timeout=10)
        resp.raise_for_status()
        countries = resp.json().get("countries", [])
    except Exception as e:
        st.error(f"Impossible de charger la liste des pays: {e}")
        return
    pays_choisi = st.selectbox("üåç Choisir un pays", options=countries)
    if not pays_choisi:
        return
    # 2) s√©rie Observ√©/Pr√©dit
    try:
        r = requests.get(f"{API_BASE_URL}/ml/predict_series/{pays_choisi}", timeout=15)
        r.raise_for_status()
        payload = r.json()
    except Exception as e:
        st.error(f"Erreur API ML: {e}")
        return
    pts = payload.get("points", [])
    if not pts:
        st.warning(f"Aucune donn√©e renvoy√©e pour {pays_choisi}")
        return
    df = pd.DataFrame(pts); df["date"] = pd.to_datetime(df["date"])
    plot_df = df.melt(id_vars=["date"], value_vars=["taux_true","taux_pred"], var_name="type", value_name="taux")
    plot_df["type"] = plot_df["type"].map({"taux_true": "Observ√©", "taux_pred": "Pr√©dit"})
    fig = px.line(plot_df, x="date", y="taux", color="type", labels={"date":"Date","taux":"Taux de transmission"})
    st.plotly_chart(fig, use_container_width=True)
    if df["taux_true"].notna().any():
        d2 = df.dropna(subset=["taux_true"])
        mae = (d2["taux_pred"] - d2["taux_true"]).abs().mean()
        rmse = (((d2["taux_pred"] - d2["taux_true"])**2).mean())**0.5
        st.caption(f"√âcarts ‚Ä¢ MAE: {mae:.2e}  |  RMSE: {rmse:.2e}")
    else:
        st.caption("√âcarts non calcul√©s (taux_true absent).")

# def page_taux_transmission():
#     st.header("üìâ Taux de transmission (observ√© vs pr√©dit)")
#     # 1) pays disponibles c√¥t√© API ML
#     try:
#         resp = requests.get(f"{API_BASE_URL}/ml/available_countries", timeout=10)
#         resp.raise_for_status()
#         countries = resp.json().get("countries", [])
#     except Exception as e:
#         st.error(f"Impossible de charger la liste des pays: {e}")
#         return
#     pays_choisi = st.selectbox("üåç Choisir un pays", options=countries)
#     if not pays_choisi:
#         return
#     # 2) s√©rie Observ√©/Pr√©dit
#     try:
#         r = requests.get(f"{API_BASE_URL}/ml/predict_series/{pays_choisi}", timeout=15)
#         r.raise_for_status()
#         payload = r.json()
#     except Exception as e:
#         st.error(f"Erreur API ML: {e}")
#         return
#     pts = payload.get("points", [])
#     if not pts:
#         st.warning(f"Aucune donn√©e renvoy√©e pour {pays_choisi}")
#         return
#     df = pd.DataFrame(pts); df["date"] = pd.to_datetime(df["date"])
#     plot_df = df.melt(id_vars=["date"], value_vars=["taux_true","taux_pred"], var_name="type", value_name="taux")
#     plot_df["type"] = plot_df["type"].map({"taux_true": "Observ√©", "taux_pred": "Pr√©dit"})
#     fig = px.line(plot_df, x="date", y="taux", color="type", labels={"date":"Date","taux":"Taux de transmission"})
#     st.plotly_chart(fig, use_container_width=True)
#     if df["taux_true"].notna().any():
#         d2 = df.dropna(subset=["taux_true"])
#         mae = (d2["taux_pred"] - d2["taux_true"]).abs().mean()
#         rmse = (((d2["taux_pred"] - d2["taux_true"])**2).mean())**0.5
#         st.caption(f"√âcarts ‚Ä¢ MAE: {mae:.2e}  |  RMSE: {rmse:.2e}")
#     else:
#         st.caption("√âcarts non calcul√©s (taux_true absent).")

def page_admin_accounts():
    st.header("üë• Comptes chercheurs (Admin)")

    # --- Tableau des utilisateurs (lecture) ---
    df_users = pd.DataFrame(
        [{"username": u, "role": USERS[u]["role"]} for u in USERS]
    ).sort_values("role")
    st.subheader("Liste des utilisateurs")
    st.table(df_users)

    # --- Cr√©ation d'un compte Chercheur (formulaire simple) ---
    st.subheader("Cr√©er un compte Chercheur")
    with st.form("create_user"):
        new_user = st.text_input("Identifiant")
        new_pwd = st.text_input("Mot de passe", type="password")
        create_ok = st.form_submit_button("Cr√©er")
    if create_ok:
        if not new_user or not new_pwd:
            st.warning("Renseigne un identifiant et un mot de passe.")
        elif new_user in USERS:
            st.error("Cet identifiant existe d√©j√†.")
        else:
            USERS[new_user] = {"password": new_pwd, "role": "RESEARCHER"}
            save_users(USERS)
            st.success(f"Compte cr√©√©: {new_user} (RESEARCHER)")
            st.rerun()

    # --- Suppression de comptes Chercheur (multi-s√©lection) ---
    st.subheader("Supprimer des comptes Chercheur")
    # On ne propose pas 'Admin' √† la suppression
    researcher_accounts = [u for u, v in USERS.items() if v.get("role") == "RESEARCHER"]
    to_delete = st.multiselect("S√©lectionne les comptes √† supprimer", researcher_accounts)

    # Confirmation via formulaire pour √©viter les clics accidentels
    with st.form("delete_users"):
        confirm = st.checkbox("Je confirme la suppression des comptes s√©lectionn√©s.")
        delete_ok = st.form_submit_button("Supprimer")
    if delete_ok:
        if not to_delete:
            st.info("Aucun compte s√©lectionn√©.")
        elif not confirm:
            st.warning("Merci de cocher la confirmation avant de supprimer.")
        else:
            for u in to_delete:
                USERS.pop(u, None)
            save_users(USERS)
            st.success(f"Comptes supprim√©s : {', '.join(to_delete)}")
            st.rerun()


# =========================
# Auth & Navigation
# =========================
def sidebar_auth_and_nav():
    role = st.session_state.role

    # Pages de base
    pages = ["üìà Vue par pays"]  # toujours visible

    # Dataviz seulement si autoris√©e ET r√¥le suffisant
    if ENABLE_DATAVIZ and role in ("RESEARCHER", "ADMIN"):
        pages += ["‚öñÔ∏è Comparaison pays"]

    # API technique (ML) seulement aux pays autoris√©s (US) ET r√¥le suffisant
    if ENABLE_TECH_API and role in ("RESEARCHER", "ADMIN"):
        pages += ["üìâ Taux de transmission"]

    # Admin
    if role == "ADMIN":
        pages += ["üë• Comptes chercheurs"]

    # Connexion/D√©connexion
    st.sidebar.markdown("---")
    st.sidebar.write(
        f"R√¥le actuel : **{role}**"
        + (f" (üë§ {st.session_state.username})" if st.session_state.username else "")
    )
    if role == "GUEST":
        if st.sidebar.button("üîê Connexion"):
            st.session_state.show_login = True
    else:
        if st.sidebar.button("üö™ D√©connexion"):
            st.session_state.role = "GUEST"
            st.session_state.username = None
            st.session_state.show_login = False

    page = st.sidebar.selectbox("üìä Choisir une page", pages, index=0)

    maladie = st.sidebar.selectbox(
        "ü¶† Maladie",
        ["covid_19", "monkeypox"],
        index=0,
        format_func=lambda x: {"covid_19":"ü¶† COVID-19 (2020-2022)",
                               "monkeypox":"üêí Monkeypox (2022-2023)"}[x]
    )
    return page, maladie

# def sidebar_auth_and_nav():
#     # ‚Äî‚Äî‚Äî Filtre pages selon le r√¥le ‚Äî‚Äî‚Äî
#     role = st.session_state.role
#     pages = ["üìà Vue par pays"]  # visible pour tout le monde (y compris GUEST)
#     if role in ("RESEARCHER", "ADMIN"):
#         pages += ["‚öñÔ∏è Comparaison pays", "üìâ Taux de transmission"]
#     if role == "ADMIN":
#         pages += ["üë• Comptes chercheurs"]

#     # ‚Äî‚Äî‚Äî Connexion/D√©connexion ‚Äî‚Äî‚Äî
#     st.sidebar.markdown("---")
#     st.sidebar.write(f"R√¥le actuel : **{role}**" + (f" (üë§ {st.session_state.username})" if st.session_state.username else ""))
#     if role == "GUEST":
#         if st.sidebar.button("üîê Connexion"):
#             st.session_state.show_login = True
#     else:
#         if st.sidebar.button("üö™ D√©connexion"):
#             st.session_state.role = "GUEST"
#             st.session_state.username = None
#             st.session_state.show_login = False

#     # ‚Äî‚Äî‚Äî Choix page uniquement quand pas sur √©cran login ‚Äî‚Äî‚Äî
#     page = st.sidebar.selectbox("üìä Choisir une page", pages, index=0)
#     # ‚Äî‚Äî‚Äî S√©lecteur commun (maladie) ‚Äî‚Äî‚Äî
#     maladie = st.sidebar.selectbox(
#         "ü¶† Maladie",
#         ["covid_19", "monkeypox"],
#         index=0,
#         format_func=lambda x: {"covid_19": "ü¶† COVID-19 (2020-2022)", "monkeypox": "üêí Monkeypox (2022-2023)"}[x]
#     )
#     return page, maladie

def login_screen():
    st.header("üîê Connexion")
    with st.form("login"):
        username = st.text_input("Identifiant")
        password = st.text_input("Mot de passe", type="password")
        ok = st.form_submit_button("Se connecter")
    if ok:
        user = USERS.get(username)
        if user and user["password"] == password:
            st.session_state.username = username
            st.session_state.role = user["role"]
            st.session_state.show_login = False
            st.success(f"Bienvenue {username} ‚Äî r√¥le: {user['role']}")
            st.rerun()
        else:
            st.error("Identifiants invalides")

# =========================
# App
# =========================
def main():
    st.title("ü¶† Dashboard Pand√©mies")

    # Ping API (comme avant)
    if not test_api():
        st.error("üö® API non disponible !")
        st.stop()
    st.success("‚úÖ API connect√©e")

    # Affiche l'√©cran de login si demand√©
    if "show_login" not in st.session_state:
        st.session_state.show_login = False
    if st.session_state.show_login:
        login_screen()
        return

    # Barre lat√©rale (pages + maladie + auth)
    page, maladie = sidebar_auth_and_nav()

    # Routage minimal selon la page
    if page == "üìà Vue par pays":
        page_vue_par_pays(maladie)
    elif page == "‚öñÔ∏è Comparaison pays":
        page_comparaison(maladie)
    elif page == "üìâ Taux de transmission":
        page_taux_transmission()
    elif page == "üë• Comptes chercheurs":
        if st.session_state.role == "ADMIN":
            page_admin_accounts()
        else:
            st.error("Acc√®s refus√©.")

if __name__ == "__main__":
    main()
